{% from 'macros.jinja' import evaluator_instance, edge_param %}

import time
from typing import Callable, Dict, Any, Literal, Optional, Tuple, cast, overload
import asyncio

import langwatch
from langwatch_nlp.studio.dspy.evaluation import (
    EvaluationResultWithMetadata,
    PredictionWithEvaluationAndMetadata,
)
from langwatch_nlp.studio.dspy.predict_with_metadata import (
    PredictionWithMetadata,
)
from langwatch_nlp.studio.parser import autoparse_fields, parse_component
from langwatch_nlp.studio.types.dsl import Workflow, Node
from langwatch_nlp.studio.dspy.reporting_module import ReportingModule
import dspy

from langwatch_nlp.studio.utils import get_node_by_id, validate_identifier
from langevals_core.base_evaluator import (
    SingleEvaluationResult,
    EvaluationResultError,
    EvaluationResult,
)
from langwatch_nlp.studio.dspy.patched_optional_image import patch_optional_image
from dspy.utils.asyncify import asyncify

{% for node in workflow.nodes|selectattr("type", "eq", "evaluator")|list %}
{{ EVALUATORS[node.data.cls]["import"] }}
{% endfor %}

patch_optional_image()

class WorkflowModule(ReportingModule):
    def __init__(
        self,
        {# TODO: support this, and remove this into actual template logic #}
        manual_execution_mode: bool = False,
        {# TODO: support this, and remove this into actual template logic #}
        until_node_id: Optional[str] = None,
        evaluation_weighting: Literal["mean"] = "mean",
    ):
        super().__init__()

        self.manual_execution_mode = manual_execution_mode

        {% for node in nodes|selectattr("type", "ne", "entry")|selectattr("type", "ne", "end")|list %}
        {% if node.type == "evaluator" %}
        self.{{ node.id }} = asyncify(self.with_reporting({{ evaluator_instance(workflow, node) }}, "{{ node.id }}"))
        {% else %}
        self.{{ node.id }} = asyncify(self.with_reporting({{ node_templates[node.id][0] }}(), "{{ node.id }}"))
        {% endif %}
        {% endfor %}

    {# TODO: migrate from inputs: Dict to actual arguments #}
    async def forward(self, inputs: Dict[str, Any]) -> dspy.Prediction:
        try:
            langwatch.get_current_span().update(type="workflow")
        except Exception:
            pass

        cost = 0
        start_time = time.time()
        error: Optional[Exception] = None

        try:

            {# First build dependency graph #}
            {% set dependency_graph = {} %}
            {% for node in nodes %}
                {% set _ = dependency_graph.update({node.id: []}) %}
            {% endfor %}
            {% for edge in workflow.edges %}
                {% set _ = dependency_graph[edge.target].append(edge.source) %}
            {% endfor %}

            {# Now generate execution layers #}
            {% set executed = {'nodes': ['entry']} %}
            {% set layers = [] %}
            {% set previous_executed_count = {'value': 0} %}

            {% if debug_level > 1 %}
            # Dependency graph: {{ dependency_graph }}
            {% endif %}

            {# Build layers until all nodes are executed #}
            {% set remaining_nodes = nodes|selectattr("type", "ne", "entry")|selectattr("type", "ne", "end")|list %}
            {% for i in range(nodes|length) %}
                {% set current_layer = [] %}

                {# Check if we're making progress - only if there are still unprocessed nodes #}
                {% set unprocessed_nodes = [] %}
                {% for node in remaining_nodes %}
                    {% if node.id not in executed.nodes %}
                        {% set _ = unprocessed_nodes.append(node.id) %}
                    {% endif %}
                {% endfor %}

                {% if unprocessed_nodes and previous_executed_count.value == executed.nodes|length and i > 0 %}
                    {{ raise("Cyclic dependency detected") }}
                {% endif %}
                {% set _ = previous_executed_count.update({'value': executed.nodes|length}) %}

                {% for node in remaining_nodes %}
                    {% set ns = namespace(can_execute=true) %}
                    {% for dep in dependency_graph[node.id] %}
                        {% if dep not in executed.nodes %}
                            {% set ns.can_execute = false %}
                        {% endif %}
                    {% endfor %}
                    {% if debug_level > 1 %}
            # {{ i }}: Node: {{ node.id }}, can execute: {{ ns.can_execute }}, executed: {{ executed.nodes }}, dependencies: {{ dependency_graph[node.id] }}
                    {% endif %}
                    {% if ns.can_execute and node.id not in executed.nodes %}
                        {% set _ = current_layer.append(node) %}
                    {% endif %}
                {% endfor %}
                {% if current_layer %}
                    {% set _ = layers.append(current_layer) %}
                    {% for node in current_layer %}
                        {% set _ = executed.nodes.append(node.id) %}
                    {% endfor %}
                {% endif %}
            {% endfor %}

            {% for layer in layers if debug_level > 0 %}
            # Layer {{ loop.index }}: {{ layer|map(attribute="id")|list }}
            {% endfor %}

            {# Generate code for each layer #}
            {% for layer in layers %}
                {% if layer|length > 1 %}
            {{ layer|map(attribute="id")|list|join(", ") }} = await asyncio.gather(
                    {% for node in layer %}
                self.{{ node.id }}(
                        {% for edge in workflow.edges %}
                            {% if edge.target == node.id %}
                                {% set source_parts = edge.sourceHandle.split(".") %}
                                {% set target_parts = edge.targetHandle.split(".") %}
                                {{ edge_param(edge, source_parts, target_parts) }}
                            {% endif %}
                        {% endfor %}
                ),
                    {% endfor %}
            )
            {% for node in layer %}
            cost += {{ node.id }}.get_cost()
            {% endfor %}

                {% else %}
            {{ layer[0].id }} = await self.{{ layer[0].id }}(
                    {% for edge in workflow.edges %}
                        {% if edge.target == layer[0].id %}
                            {% set source_parts = edge.sourceHandle.split(".") %}
                            {% set target_parts = edge.targetHandle.split(".") %}
                            {{ edge_param(edge, source_parts, target_parts) }}
                        {% endif %}
                    {% endfor %}
            )
            {# TODO: move this to parent class probably #}
            cost += {{ layer[0].id }}.get_cost()

                {% endif %}
            {% endfor %}

        except Exception as e:
            error = e
            if self.manual_execution_mode:
                raise e

        {# Finally execute end node #}
        {% set ns = namespace(end_node=None) %}
        {% for node in workflow.nodes %}
            {% if node.type == "end" %}
                {% set ns.end_node = node %}
            {% endif %}
        {% endfor %}

        return PredictionWithEvaluationAndMetadata(
            end={
                {% for edge in workflow.edges %}
                    {% if edge.target == ns.end_node.id %}
                        {% set source_parts = edge.sourceHandle.split(".") %}
                        {% set target_parts = edge.targetHandle.split(".") %}
                        {% if edge.source == "entry" %}
                "{{ target_parts[1] }}": inputs["{{ source_parts[1] }}"],
                        {% else %}
                "{{ target_parts[1] }}": {{ edge.source }}.{{ source_parts[1] }},
                        {% endif %}
                    {% endif %}
                {% endfor %}
            },
            {% for node in nodes|selectattr("type", "ne", "entry")|selectattr("type", "ne", "end")|list %}
            {{ node.id }}={{ node.id }},
            {% endfor %}
            cost=cost,
            duration=round((time.time() - start_time) * 1000),
            error=error,
            {# # TODO: rename this to evaluate #}
            evaluation=self.evaluate_prediction,
        )

    def evaluate_prediction(
        self,
        example: dspy.Example,
        prediction: PredictionWithMetadata,
        trace: Optional[Any] = None,
        return_results: bool = False,
    ) -> float | tuple[float, dict[str, EvaluationResultWithMetadata]]:
        pass

{% for node_id, node_template in node_templates.items() %}
{{ node_template[1] }}
{% endfor %}